#!/bin/bash
dbg() {
  echo "$(date -Iseconds): $0 $*" >> "$HOME"/bootstrappy.log
  if [[ -n $BOOTSTRAPPY_VERBOSE ]]; then
    printf "\001\033[0;38;2;100;150;150m\002%s\001\033[0m\002: " "bootstrappy" >&2
    printf "%s" "$*" >&2
    printf "\n" >&2
  fi
}

die() {
  printf "\001\033[0;38;2;200;15;15m\002%s\001\033[0m\002: error: " "$progname" >&2
  printf "%s" "$*" >&2
  printf "\n" >&2
  exit 1
}

# Parse github:owner/repo@ref spec into repo_path and ref variables
parse_github_spec() {
  local spec="$1"
  spec="${spec#github:}"  # Remove github: prefix

  if [[ "$spec" == *@* ]]; then
    repo_path="${spec%@*}"
    ref="${spec#*@}"
  else
    repo_path="$spec"
    ref="HEAD"
  fi

  # Validate format: owner/repo
  if ! [[ "$repo_path" =~ ^[a-zA-Z0-9_-]+/[a-zA-Z0-9_.-]+$ ]]; then
    die "invalid github repo: $repo_path"
  fi
  # Validate ref format
  if ! [[ "$ref" =~ ^[a-zA-Z0-9_./-]+$ ]]; then
    die "invalid github ref: $ref"
  fi
}

install_from_github() {
  local env_dir="$1"
  local spec="$2"

  parse_github_spec "$spec"
  local repo_name="${repo_path#*/}"
  local src_dir="$HOME/.bootstrappy/src/$repo_name"

  if [[ -d "$src_dir/.git" ]]; then
    dbg "updating $repo_path (ref=$ref)"
    git -C "$src_dir" fetch origin || die "failed to fetch $repo_path"
    git -C "$src_dir" checkout "$ref" || die "failed to checkout $ref"
  else
    dbg "cloning $repo_path"
    mkdir -p "$(dirname "$src_dir")"
    git clone "https://github.com/$repo_path.git" "$src_dir" || die "failed to clone $repo_path"
    if [[ "$ref" != "HEAD" ]]; then
      dbg "checking out $ref"
      git -C "$src_dir" checkout "$ref" || die "failed to checkout $ref"
    fi
  fi

  dbg "installing from $src_dir"
  "$env_dir"/bin/python -muv pip install -e "$src_dir" >&2 || die "failed to install from $src_dir"
}

raw_toolname="$(basename "$0")"
if [[ "$raw_toolname" = bootstrappy ]]; then
  progname="bootstrappy"
  die "use: ln -s your_tool bootstrappy" >&2
fi

# Validate toolname to prevent injection
if ! [[ "$raw_toolname" =~ ^[a-zA-Z0-9_-]+$ ]]; then
  progname="bootstrappy"
  die "invalid tool name: $raw_toolname"
fi

if [[ -x .venv/bin/"$raw_toolname" ]]; then
  # This tool already exists inside the local virtualenv.
  dbg "running $raw_toolname from $PWD/.venv/bin [PWD='$PWD', args=($*)]"
  if [[ -n $BOOTSTRAPPY_VERBOSE ]]; then
    tmpfile="$(mktemp)"
    trap 'rm '"$tmpfile" EXIT
    /usr/bin/time -o "$tmpfile" .venv/bin/"$raw_toolname" "$@"
    res=$?
    dbg "$raw_toolname took $(cat "$tmpfile") [res=$res]"
    exit "$res"
  else
    exec .venv/bin/"$raw_toolname" "$@"
  fi
fi

# shellcheck disable=SC1091
dbg "sourcing $HOME/.bootstrappyrc"
# shellcheck disable=SC1091
. "$HOME/.bootstrappyrc"

toolname="${raw_toolname//-/_}"
progname="bootstrappy[$raw_toolname]"


install() {
  env_dir="$1"
  package="$2"

  if ! [[ -x "$env_dir"/bin/uv ]]; then
    if [[ -z "$allow_making_venv" ]]; then
      dbg "no env_dir/bin/uv [env_dir=$env_dir]"
      return 1
    fi
    # Ensure that uv is installed.
    dbg "installing uv"
    "$env_dir"/bin/python -mpip install -U uv pyyaml types-PyYAML || die "installing uv"
  fi

  if [[ "$package" == github:* ]]; then
    install_from_github "$env_dir" "$package"
  else
    dbg "bootstrappy: installing $package"
    "$env_dir"/bin/python -muv pip install "$package" >&2 || die "failed to install $package"
  fi
}

try-env-dir() {
  env_dir="$1"
  allow_making_venv="$2"
  shift 2
  if ! [[ -f "$env_dir"/pyvenv.cfg ]]; then
    if [[ -z "$allow_making_venv" ]]; then
      dbg "no env_dir/pyvenv [env_dir=$env_dir]"
      return 1
    fi
    # Make sure the bootstrappy virtual environment is set up.
    dbg "creating $(dirname "$env_dir")"
    mkdir -p "$(dirname "$env_dir")"
    dbg "installing venv"
    python3 -mvenv "$env_dir" || die "creating $env_dir venv"
  fi

  if ! [[ -x "$env_dir"/bin/"$raw_toolname" ]]; then
    if [[ -z "$allow_making_venv" ]]; then
      dbg "no env_dir/bin/$raw_toolname [env_dir=$env_dir]"
      return 1
    fi
    # It looks like our tool is not installed.
    if [[ -n "${!toolname}" ]]; then
      # User has defined an override for this toolname's installation package.
      dbg "[bootstrappy] using .bootstrappyrc override for $toolname=${!toolname}"
      install "$env_dir" "${!toolname}"
    else
      # Use the raw toolname itself as an installation package.
      install "$env_dir" "$raw_toolname"
    fi
    if ! [[ -x "$env_dir"/bin/"$raw_toolname" ]]; then
      die "installation of '$raw_toolname' failed [toolname='$toolname', resolved='${!toolname}']"
    fi
  fi

  dbg "execing '$env_dir/bin/$raw_toolname' with args=($*)"
  "$env_dir"/bin/"$raw_toolname" "$@"
  res="$?"
  dbg "exited with code ($res)"
  exit "$res"
}
try-env-dir "$PWD"/.venv '' "$@"
try-env-dir "$HOME"/.bootstrappy '1' "$@"

